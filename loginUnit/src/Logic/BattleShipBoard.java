package Logic;

import AutoGeneratedClasses.BattleShipGame;
import Exceptions.CorruptedXMLException;
import Exceptions.MineInstallationException;

import java.io.Serializable;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class BattleShipBoard implements Serializable {
    private static final long serialVersionUID = 2L;
    private BattleShipSquare[][] board;
    private int boardSize;
    private int uniqueIDCounter = 0;
    private int numOfAliveShips = 0;
    private int numOfAvailableMines;
    private Map<Integer, BattleShipStatus> idCounterToBattleShipStatusMap = new HashMap<Integer, BattleShipStatus>();

    public class BattleShipStatus implements Serializable {
        private static final long serialVersionUID = 12L;
        private int score;
        private int life;
        private BattleShipGame.ShipTypes.ShipType type;

        public BattleShipStatus(int i_Score, int i_Life, BattleShipGame.ShipTypes.ShipType i_Type) {
            score = i_Score;
            life = i_Life;
            type = i_Type;
        }

        public int GetScore() {
            return score;
        }

        public int GetLife() {
            return life;
        }

        public BattleShipGame.ShipTypes.ShipType GetType() {
            return type;
        }

        public void SetLife(int i_Life) {
            life = i_Life;
        }
    }

    public class BattleShipSquare implements Serializable {
        private static final long serialVersionUID = 3L;
        private boolean wasAttackedByPlayer;
        private boolean wasAttackedByBackFire;
        private boolean isBattleShipHere;
        private boolean isMineHere;
        private int uniqueID;

        public BattleShipSquare() {
            wasAttackedByPlayer = false;
            wasAttackedByBackFire = false;
            isBattleShipHere = false;
            isMineHere = false;
            uniqueID = 0;
        }

        public void SetBattleShipSquare(boolean i_WasAttackedByPlayer, boolean i_WasAttackByBackFire, boolean i_IsBattleShipHere, boolean i_IsMineHere, int i_UniqueID) {
            wasAttackedByPlayer = i_WasAttackedByPlayer;
            wasAttackedByBackFire = i_WasAttackByBackFire;
            isBattleShipHere = i_IsBattleShipHere;
            isMineHere = i_IsMineHere;
            uniqueID = i_UniqueID;
        }

        public boolean GetIsBattleShipHere() {
            return isBattleShipHere;
        }

        public boolean GetIsMineHere() {
            return isMineHere;
        }

        public void SetWasAttackedByPlayer(boolean i_WasAttackedByPlayer) {
            wasAttackedByPlayer = i_WasAttackedByPlayer;
        }

        public boolean GetWasAttackedByPlayer() {
            return wasAttackedByPlayer;
        }

        public void SetWasAttackedByBackFire(boolean i_WasAttackedByBackFire) {
            wasAttackedByBackFire = i_WasAttackedByBackFire;
        }

        public boolean GetWasAttackedByBackFire() {
            return wasAttackedByBackFire;
        }

        public boolean GetIsEmpty() {
            return wasAttackedByPlayer == false && wasAttackedByBackFire == false && isBattleShipHere == false && isMineHere == false;
        }

        public void SetIsBattleShipHere(boolean i_IsBattleShipHere) {
            isBattleShipHere = i_IsBattleShipHere;
        }

        public void SetIsMineHere(boolean i_IsMineHere) {
            isMineHere=i_IsMineHere;
        }
    }

    public int GetNumOfAvailableMines(){
        return numOfAvailableMines;
    }

    public int GetUniqueIDCounter(int i_Row, int i_Column) {
        return board[i_Row][i_Column].uniqueID;
    }

    public Map<Integer, BattleShipStatus> GetIdCounterToBattleShipStatusMap() {
        return idCounterToBattleShipStatusMap;
    }

    public int GetBoardSize() {
        return boardSize;
    }

    public void SetNumOfAliveShips(int i_NumOfAliveShips) {
        numOfAliveShips = i_NumOfAliveShips;
    }

    public int GetNumOfAliveShips() {
        return numOfAliveShips;
    }

    public BattleShipSquare[][] GetBoard() {
        return board;
    }

    public void Initialize(BattleShipGame i_Game, int i_PlayerIndex) throws CorruptedXMLException {
        initBoard(i_Game);
        uniqueIDCounter++;
        validateShipTypes(i_Game.getShipTypes().getShipType(), i_Game.getGameType());
        Map<String, Integer> IdToAmountMap = new HashMap<String, Integer>();
        List<BattleShipGame.Boards.Board> boardsList = i_Game.getBoards().getBoard();
        List<BattleShipGame.Boards.Board.Ship> shipsList = boardsList.get(i_PlayerIndex).getShip();
        for (BattleShipGame.Boards.Board.Ship ship : shipsList) {
            insertShipToBoard(i_Game, ship);
            String typeId = ship.getShipTypeId();
            Integer value = IdToAmountMap.get(typeId);
            if (value == null)
                IdToAmountMap.put(typeId, 1);
            else
                IdToAmountMap.put(typeId, value + 1);

            uniqueIDCounter++;
        }
        examineNumberOfBattleShips(i_Game, i_PlayerIndex, IdToAmountMap);
    }

    private void validateShipTypes(List<BattleShipGame.ShipTypes.ShipType> i_ShipTypes, String i_GameType) throws CorruptedXMLException {
        for (BattleShipGame.ShipTypes.ShipType shipType : i_ShipTypes) {
            int counter = 0;
            for (BattleShipGame.ShipTypes.ShipType shipTypeToCheck : i_ShipTypes) {
                if (shipType.getId().compareTo(shipTypeToCheck.getId()) == 0)
                    counter++;
                if (counter > 1)
                    throw new CorruptedXMLException("The ship type id " + shipType.getId() + " is listed more than once in the XML file.");
            }

            if (shipType.getAmount() < 1)
                throw new CorruptedXMLException(shipType.getId() + " is not valid - the amount of ships of must be at least one.");
            if (shipType.getLength() < 1)
                throw new CorruptedXMLException(shipType.getId() + " is not valid - the length of a ship must be at least one.");
            if (shipType.getScore() < 1)
                throw new CorruptedXMLException(shipType.getId() + " is not valid - the score of a ship must be at least one.");
            if (shipType.getCategory().compareTo("REGULAR") != 0 && shipType.getCategory().compareTo("L_SHAPE") != 0)
                throw new CorruptedXMLException(shipType.getId() + " is not valid - only categories REGULAR and L_SHAPE are supported.");
            if (shipType.getCategory().compareTo("L_SHAPE") == 0 && i_GameType.compareTo("BASIC") == 0)
                throw new CorruptedXMLException("BASIC type game does not support L_SHPAE battleships.");
        }
    }

    public void InstallMine(int i_Row, int i_Column) throws MineInstallationException {
        if (board[i_Row][i_Column].wasAttackedByPlayer || board[i_Row][i_Column].wasAttackedByBackFire)
            throw new MineInstallationException(String.format("The square [%1d,%1d] has been already attacked and therefor you cannot install a mine there.", i_Row + 1, i_Column + 1));
        if (numOfAvailableMines <= 0)
            throw new MineInstallationException("Cannot install any more mines - you have exceeded the maximum amount.");
        try {
            checkOverlapAndSpaceAndOutOfBoundaries("Mine", i_Row, i_Column);
            board[i_Row][i_Column].isMineHere = true;
            board[i_Row][i_Column].uniqueID = uniqueIDCounter;
            uniqueIDCounter++;
            numOfAvailableMines--;
        } catch (Exception ex) {
            throw new MineInstallationException(ex.getMessage());
        }
    }

    private void examineNumberOfBattleShips(BattleShipGame i_Game, int i_PlayerIndex, Map<String, Integer> i_IdToAmountMap) throws CorruptedXMLException {
        List<BattleShipGame.Boards.Board> boardsList = i_Game.getBoards().getBoard();
        List<BattleShipGame.Boards.Board.Ship> shipsList = boardsList.get(i_PlayerIndex).getShip();
        for (BattleShipGame.Boards.Board.Ship ship : shipsList) {
            BattleShipGame.ShipTypes.ShipType shipType = getShipType(i_Game, ship);
            String id = shipType.getId();
            Integer value = i_IdToAmountMap.get(id);
            if (value != shipType.getAmount())
                throw new CorruptedXMLException("The amount of battleships of " + id + " that was located on the board doesn't match the amount given in the XML section.");
        }
    }

    private void initBoard(BattleShipGame i_Game) throws CorruptedXMLException {
        idCounterToBattleShipStatusMap.clear();
        uniqueIDCounter = 0;
        numOfAliveShips = 0;
        if(i_Game.getGameType().compareTo("ADVANCE") == 0){
            numOfAvailableMines = i_Game.getMine().getAmount();
            if(numOfAvailableMines < 0)
                throw new CorruptedXMLException("Illegal amount of mines - amount cannot be a negative number.");
        }
        boardSize = i_Game.getBoardSize();
        if (boardSize < 5 || boardSize > 20)
            throw new CorruptedXMLException("Illegal board size - board size must be in the range of 5-20.");
        board = new BattleShipSquare[boardSize][boardSize];
        for (int i = 0; i < boardSize; i++)
            for (int j = 0; j < boardSize; j++)
                board[i][j] = new BattleShipSquare();
    }

    private void insertShipToBoard(BattleShipGame i_Game, BattleShipGame.Boards.Board.Ship i_Ship) throws CorruptedXMLException {
        int shipLength = getShipLength(i_Game, i_Ship);
        int shipScore = getShipScore(i_Game, i_Ship);
        int row = i_Ship.getPosition().getX() - 1;
        int column = i_Ship.getPosition().getY() - 1;
        for (int i = 0; i < shipLength; i++) {
            try {
                if ((i_Ship.getDirection().compareTo("ROW") == 0) || (i_Ship.getDirection().compareTo("UP_RIGHT") == 0) || (i_Ship.getDirection().compareTo("DOWN_RIGHT") == 0)) {
                    checkOverlapAndSpaceAndOutOfBoundaries("Battleship", row, column + i);
                    board[row][column + i].SetBattleShipSquare(false, false, true, false, uniqueIDCounter);
                } else if (i_Ship.getDirection().compareTo("COLUMN") == 0) {
                    checkOverlapAndSpaceAndOutOfBoundaries("Battleship", row + i, column);
                    board[row + i][column].SetBattleShipSquare(false, false, true, false, uniqueIDCounter);
                } else if ((i_Ship.getDirection().compareTo("RIGHT_DOWN") == 0) || (i_Ship.getDirection().compareTo("RIGHT_UP") == 0)) {
                    checkOverlapAndSpaceAndOutOfBoundaries("Battleship", row, column - i);
                    board[row][column - i].SetBattleShipSquare(false, false, true, false, uniqueIDCounter);
                } else
                    throw new CorruptedXMLException("Direction type is not supported.");
            } catch (Exception ex) {
                throw new CorruptedXMLException(ex.getMessage());
            }
        }

        if ((i_Ship.getDirection().compareTo("ROW") == 0) || (i_Ship.getDirection().compareTo("COLUMN") == 0)){
            numOfAliveShips += shipLength;
            idCounterToBattleShipStatusMap.put(uniqueIDCounter, new BattleShipStatus(shipScore, shipLength, getShipType(i_Game, i_Ship)));
        }
        else {
            for (int i = 1; i < shipLength; i++) {
                try {
                    if ((i_Ship.getDirection().compareTo("UP_RIGHT") == 0) || (i_Ship.getDirection().compareTo("RIGHT_DOWN") == 0)) {
                        checkOverlapAndSpaceAndOutOfBoundaries("Battleship", row + i, column);
                        board[row + i][column].SetBattleShipSquare(false, false, true, false, uniqueIDCounter);
                    } else if ((i_Ship.getDirection().compareTo("RIGHT_UP") == 0) || (i_Ship.getDirection().compareTo("DOWN_RIGHT") == 0)) {
                        checkOverlapAndSpaceAndOutOfBoundaries("Battleship", row - i, column);
                        board[row - i][column].SetBattleShipSquare(false, false, true, false, uniqueIDCounter);
                    }
                } catch (Exception ex) {
                    throw new CorruptedXMLException(ex.getMessage());
                }
            }
            int realLength = (shipLength * 2) - 1;
            numOfAliveShips += realLength;
            idCounterToBattleShipStatusMap.put(uniqueIDCounter, new BattleShipStatus(shipScore, realLength, getShipType(i_Game, i_Ship)));
        }
    }

    private void checkOverlapAndSpaceAndOutOfBoundaries(String i_Indentifier, int i_Row, int i_Column) throws Exception {
        if (!isSquareInBoardBoundaries(i_Row, i_Column))
            throw new Exception(String.format(i_Indentifier + " at coordinates [%1d,%1d] is out of board boundaries.", i_Row + 1, i_Column + 1));
        if (board[i_Row][i_Column].isBattleShipHere == true)
            throw new Exception(String.format(i_Indentifier + " overlaps a battleship at coordinates [%1d,%1d].", i_Row + 1, i_Column + 1));
        if (board[i_Row][i_Column].isMineHere == true)
            throw new Exception(String.format(i_Indentifier + " overlaps a mine at coordinates [%1d,%1d].", i_Row + 1, i_Column + 1));
        if (isSquareInBoardBoundaries(i_Row + 1, i_Column + 1)) {
            if (board[i_Row + 1][i_Column + 1].isBattleShipHere == true && board[i_Row + 1][i_Column + 1].uniqueID != uniqueIDCounter)
                throw new Exception(String.format("Not enough space between " + i_Indentifier + " at coordinates [%1d,%1d] and battleship at coordinates [%1d,%1d].", i_Row + 1, i_Column + 1, i_Row + 1 + 1, i_Column + 1 + 1));
            if (board[i_Row + 1][i_Column + 1].isMineHere == true)
                throw new Exception(String.format("Not enough space between " + i_Indentifier + " at coordinates [%1d,%1d] and mine at coordinates [%1d,%1d].", i_Row + 1, i_Column + 1, i_Row + 1 + 1, i_Column + 1 + 1));
        }
        if (isSquareInBoardBoundaries(i_Row + 1, i_Column)) {
            if (board[i_Row + 1][i_Column].isBattleShipHere == true && board[i_Row + 1][i_Column].uniqueID != uniqueIDCounter)
                throw new Exception(String.format("Not enough space between " + i_Indentifier + " at coordinates [%1d,%1d] and battleship at coordinates [%1d,%1d].", i_Row + 1, i_Column + 1, i_Row + 1 + 1, i_Column + 1));
            if (board[i_Row + 1][i_Column].isMineHere == true)
                throw new Exception(String.format("Not enough space between " + i_Indentifier + " at coordinates [%1d,%1d] and mine at coordinates [%1d,%1d].", i_Row + 1, i_Column + 1, i_Row + 1 + 1, i_Column + 1));
        }
        if (isSquareInBoardBoundaries(i_Row + 1, i_Column - 1)) {
            if (board[i_Row + 1][i_Column - 1].isBattleShipHere == true && board[i_Row + 1][i_Column - 1].uniqueID != uniqueIDCounter)
                throw new Exception(String.format("Not enough space between " + i_Indentifier + " at coordinates [%1d,%1d] and battleship at coordinates [%1d,%1d].", i_Row + 1, i_Column + 1, i_Row + 1 + 1, i_Column));
            if (board[i_Row + 1][i_Column - 1].isMineHere == true)
                throw new Exception(String.format("Not enough space between " + i_Indentifier + " at coordinates [%1d,%1d] and mine at coordinates [%1d,%1d].", i_Row + 1, i_Column + 1, i_Row + 1 + 1, i_Column));
        }
        if (isSquareInBoardBoundaries(i_Row, i_Column + 1)) {
            if (board[i_Row][i_Column + 1].isBattleShipHere == true && board[i_Row][i_Column + 1].uniqueID != uniqueIDCounter)
                throw new Exception(String.format("Not enough space between " + i_Indentifier + " at coordinates [%1d,%1d] and battleship at coordinates [%1d,%1d].", i_Row + 1, i_Column + 1, i_Row + 1, i_Column + 1 + 1));
            if (board[i_Row][i_Column + 1].isMineHere == true)
                throw new Exception(String.format("Not enough space between " + i_Indentifier + " at coordinates [%1d,%1d] and mine at coordinates [%1d,%1d].", i_Row + 1, i_Column + 1, i_Row + 1, i_Column + 1 + 1));
        }
        if (isSquareInBoardBoundaries(i_Row, i_Column - 1)) {
            if (board[i_Row][i_Column - 1].isBattleShipHere == true && board[i_Row][i_Column - 1].uniqueID != uniqueIDCounter)
                throw new Exception(String.format("Not enough space between " + i_Indentifier + " at coordinates [%1d,%1d] and battleship at coordinates [%1d,%1d].", i_Row + 1, i_Column + 1, i_Row + 1, i_Column));
            if (board[i_Row][i_Column - 1].isMineHere == true)
                throw new Exception(String.format("Not enough space between " + i_Indentifier + " at coordinates [%1d,%1d] and mine at coordinates [%1d,%1d].", i_Row + 1, i_Column + 1, i_Row + 1, i_Column));
        }
        if (isSquareInBoardBoundaries(i_Row - 1, i_Column + 1)) {
            if (board[i_Row - 1][i_Column + 1].isBattleShipHere == true && board[i_Row - 1][i_Column + 1].uniqueID != uniqueIDCounter)
                throw new Exception(String.format("Not enough space between " + i_Indentifier + " at coordinates [%1d,%1d] and battleship at coordinates [%1d,%1d].", i_Row + 1, i_Column + 1, i_Row, i_Column + 1 + 1));
            if (board[i_Row - 1][i_Column + 1].isMineHere == true)
                throw new Exception(String.format("Not enough space between " + i_Indentifier + " at coordinates [%1d,%1d] and mine at coordinates [%1d,%1d].", i_Row + 1, i_Column + 1, i_Row, i_Column + 1 + 1));
        }
        if (isSquareInBoardBoundaries(i_Row - 1, i_Column)) {
            if (board[i_Row - 1][i_Column].isBattleShipHere == true && board[i_Row - 1][i_Column].uniqueID != uniqueIDCounter)
                throw new Exception(String.format("Not enough space between " + i_Indentifier + " at coordinates [%1d,%1d] and battleship at coordinates [%1d,%1d].", i_Row + 1, i_Column + 1, i_Row, i_Column + 1));
            if (board[i_Row - 1][i_Column].isMineHere == true)
                throw new Exception(String.format("Not enough space between " + i_Indentifier + " at coordinates [%1d,%1d] and mine at coordinates [%1d,%1d].", i_Row + 1, i_Column + 1, i_Row, i_Column + 1));
        }
        if (isSquareInBoardBoundaries(i_Row - 1, i_Column - 1)) {
            if (board[i_Row - 1][i_Column - 1].isBattleShipHere == true && board[i_Row - 1][i_Column - 1].uniqueID != uniqueIDCounter)
                throw new Exception(String.format("Not enough space between " + i_Indentifier + " at coordinates [%1d,%1d] and battleship at coordinates [%1d,%1d].", i_Row + 1, i_Column + 1, i_Row, i_Column));
            if (board[i_Row - 1][i_Column - 1].isMineHere == true)
                throw new Exception(String.format("Not enough space between " + i_Indentifier + " at coordinates [%1d,%1d] and mine at coordinates [%1d,%1d].", i_Row + 1, i_Column + 1, i_Row, i_Column));
        }
    }

    private boolean isSquareInBoardBoundaries(int i_Row, int i_Column) {
        if (i_Row >= boardSize || i_Column >= boardSize || i_Row < 0 || i_Column < 0)
            return false;
        return true;
    }

    private int getShipScore(BattleShipGame i_Game, BattleShipGame.Boards.Board.Ship i_Ship) throws CorruptedXMLException {
        return getShipType(i_Game, i_Ship).getScore();
    }

    private int getShipLength(BattleShipGame i_Game, BattleShipGame.Boards.Board.Ship i_Ship) throws CorruptedXMLException {
        return getShipType(i_Game, i_Ship).getLength();
    }

    private BattleShipGame.ShipTypes.ShipType getShipType(BattleShipGame i_Game, BattleShipGame.Boards.Board.Ship i_Ship) throws CorruptedXMLException {
        List<BattleShipGame.ShipTypes.ShipType> shipTypes = i_Game.getShipTypes().getShipType();
        for (BattleShipGame.ShipTypes.ShipType shipType : shipTypes)
            if (shipType.getId().compareTo(i_Ship.getShipTypeId()) == 0)
                return shipType;

        throw new CorruptedXMLException("Ship type is not supported.");
    }
}