package Logic;

import AutoGeneratedClasses.BattleShipGame;
import Exceptions.*;
import javafx.beans.property.SimpleIntegerProperty;
import java.io.*;
import java.time.Duration;
import java.time.LocalDateTime;
import java.time.ZonedDateTime;
import java.util.*;
import java.util.concurrent.TimeUnit;
import javax.xml.bind.*;

public class LogicUnitManager {
    public final int BATTLESHIP_BOARD_TYPE = 0;
    public final int TRACKING_BOARD_TYPE = 1;
    private String gameType;
    private BattleShipGame game;
    private int playerTurn;
    private Utils.Statistics statistics;
    private List<Player> players = new ArrayList<Player>(2);
    private final float TO_SECONDS = 1000;
    private MakeMoveResult makeMoveResult;
    private String filePath;
    private List<SingleMoveInformation> moves = new ArrayList<>();
    private int moveIndex;
    private ZonedDateTime startTime;
    private boolean isGameRunning;

    private Map<String, SimpleIntegerProperty> shipTypeIdToAmountMap;

    public boolean GetIsGameRunning(){return isGameRunning;}

    public Player GetCurrentPlayer(){return players.get(playerTurn);}

    public int GetCurrentPlayerTurn() {
        return playerTurn;
    }

    public int GetBoardSize() {
        return game.getBoardSize();
    }

    private void updateEnemyInformation() {
        List<BattleShipGame.ShipTypes.ShipType> shipTypesList = players.get(playerTurn).GetEnemyShipsInformation();
        for (BattleShipGame.ShipTypes.ShipType type : shipTypesList) {
            SimpleIntegerProperty value = shipTypeIdToAmountMap.get(type.getId());
            value.set(type.getAmount());
        }
    }

    public List<BattleShipGame.ShipTypes.ShipType> GetShipTypesList() {
        return game.getShipTypes().getShipType();
    }

    public Map<String, SimpleIntegerProperty> GetShipsMap() {
        return shipTypeIdToAmountMap;
    }

    public BattleShipGame.ShipTypes.ShipType GetShipTypeById(String id) {
        List<BattleShipGame.ShipTypes.ShipType> lst = GetShipTypesList();
        for (BattleShipGame.ShipTypes.ShipType type : lst) {
            if (type.getId().compareTo(id) == 0)
                return type;
        }

        return null;
    }

    public BattleShipBoard.BattleShipSquare GetCurrentPlayerBattleshipSquareInformation(int i_Row, int i_Column) {
        return players.get(playerTurn).GetBattleShipBoard().GetBoard()[i_Row][i_Column];
    }

    public TrackingBoard.TrackingSquare GetCurrentPlayerTrackingSquareInformation(int i_Row, int i_Column) {
        return players.get(playerTurn).GetTrackingBoard().GetBoard()[i_Row][i_Column];
    }

    public void updatePlayersName(List<String> playersNames) {
        for(int i = 0; i < players.size(); ++i)
            players.get(i).SetPlayerName(playersNames.get(i));

        statistics.SetFirstPlayerName(playersNames.get(0));
        statistics.SetSecondPlayerName(playersNames.get(1));
    }

    public Player GetPlayerInformationByName(String usernameFromSession) {
        for(Player player: players){
            if(usernameFromSession.compareTo(player.GetPlayerName()) == 0)
                return player;
        }

        return null;
    }

    public String GetGameType() {
        return gameType;
    }

    public class MakeMoveResult {
        Player.HitResult hitResult;
        boolean isGameFinished;

        public String GetHitObject() {
            return hitResult.hitObject;
        }

        public boolean GetIsShipSank() {
            return hitResult.isShipSank;
        }

        public boolean GetIsGameFinished() {
            return isGameFinished;
        }
    }

    public LogicUnitManager() {
        players.add(new Player(0));
        players.add(new Player(1));
        statistics = new Utils().new Statistics();
        makeMoveResult = new MakeMoveResult();
        shipTypeIdToAmountMap = new HashMap<>();
    }

    public void LoadGameInformation(String i_FilePath, String i_GameName, String i_GameCreator) throws BadInputFileException, JAXBException {
        if (!i_FilePath.endsWith(".xml") && !i_FilePath.endsWith(".XML"))
            throw new BadInputFileException("This is not an XML file.");

        File file = new File(i_FilePath);
        if (!file.isFile())
            throw new BadInputFileException("File does not exist.");

        try {
            JAXBContext jaxbContext = JAXBContext.newInstance(BattleShipGame.class);
            Unmarshaller jaxbUnmarshaller = jaxbContext.createUnmarshaller();
            game = (BattleShipGame) jaxbUnmarshaller.unmarshal(file);
            filePath = i_FilePath;
        } catch (JAXBException e) {
            throw new JAXBException("JAXBException has been thrown.");
        }
    }

    public void InitializeGame() throws CorruptedXMLException, BadInputFileException, JAXBException {
        gameType = game.getGameType();
        if (gameType.compareTo("BASIC") != 0 && gameType.compareTo("ADVANCE") != 0)
            throw new CorruptedXMLException("Game type is not supported.");

        initDataMembers();
        for (Player player : players) {
            player.InitializePlayer(game);
        }
        initializeMap();
        updateMovesList(-1, -1, -1);
    }

    private void initializeMap() {
        List<BattleShipGame.ShipTypes.ShipType> lst = game.getShipTypes().getShipType();
        for (BattleShipGame.ShipTypes.ShipType type : lst) {
            shipTypeIdToAmountMap.put(type.getId(), new SimpleIntegerProperty());
        }
    }

    private void initDataMembers() {
        statistics.SetStartTime(LocalDateTime.now());
        playerTurn = 0;
        moveIndex = 0;
        shipTypeIdToAmountMap.clear();
        moves.clear();
        startTime = ZonedDateTime.now();
        isGameRunning = true;
    }

    public MakeMoveResult MakeMove(int i_Row, int i_Column) throws Exception {
        if (isGameRunning) {
            long timeDiff = calcTimeToMakeMove();
            makeMoveResult.hitResult = players.get(playerTurn).Attack(i_Row, i_Column, players.get((playerTurn + 1) % 2));
            updateStatistics(timeDiff);
            updateMovesList(i_Row, i_Column, TRACKING_BOARD_TYPE);
            makeMoveResult.isGameFinished = (players.get(playerTurn).GetBattleShipBoard().GetNumOfAliveShips() == 0)
                    || (players.get((playerTurn + 1) % 2).GetBattleShipBoard().GetNumOfAliveShips() == 0);

            if (makeMoveResult.isGameFinished) {
                isGameRunning = false;
                moveIndex--;
                if (players.get(playerTurn).GetBattleShipBoard().GetNumOfAliveShips() == 0)
                    playerTurn = (playerTurn + 1) % 2;
                statistics.SetWinnerName(players.get(playerTurn).GetPlayerName());
            } else {
                if ((makeMoveResult.hitResult.hitObject.compareTo("Miss") == 0) || (makeMoveResult.hitResult.hitObject.compareTo("Mine") == 0))
                    playerTurn = (playerTurn + 1) % 2;
            }
            return makeMoveResult;
        }
        throw new Exception("Game is no longer running.");
    }

    private long calcTimeToMakeMove() {
        ZonedDateTime endTime = ZonedDateTime.now();
        Duration diff = Duration.between(startTime, endTime);
        System.out.println("move duration (in millis): " + diff.toMillis());
        startTime = ZonedDateTime.now();
        return diff.toMillis();
    }

    private void updateMovesList(int i_Row, int i_Column, int i_BoardType) {
        SingleMoveInformation move = new SingleMoveInformation(game.getBoardSize());
        move.SetBattleshipBoard(players.get(playerTurn).GetBattleShipBoard().GetBoard());
        move.SetTrackingBoard(players.get(playerTurn).GetTrackingBoard().GetBoard());
        move.SetPlayer(String.valueOf(playerTurn + 1));
        move.SetScore(players.get(playerTurn).GetScore());
        move.SetHit(players.get(playerTurn).GetHit());
        move.SetMiss(players.get(playerTurn).GetMiss());
        move.SetAverageMoveTime(calcAverageTime(playerTurn));
        move.SetNumOfMines(players.get(playerTurn).GetNumOfMinesLeft());
        move.SetShipTypeList(players.get(playerTurn).GetEnemyShipsInformation());
        move.SetNumOfTurns(players.get(playerTurn).GetNumOfTurnsPlayed());
        move.SetRow(i_Row);
        move.SetColumn(i_Column);
        move.SetBoardType(i_BoardType);
        moves.add(move);
        moveIndex++;
    }

    public Utils.Statistics GetStatistics() {
        LocalDateTime currentTime = LocalDateTime.now();
        long timeElapsed = Duration.between(statistics.GetStartTime(), currentTime).toMillis();
        String ms = String.format("%02d:%02d", TimeUnit.MILLISECONDS.toMinutes(timeElapsed),
                TimeUnit.MILLISECONDS.toSeconds(timeElapsed) - TimeUnit.MINUTES.toSeconds(TimeUnit.MILLISECONDS.toMinutes(timeElapsed)));
        statistics.SetTimeElapsedSinceGameStarted(ms);
        statistics.SetFirstPlayerScore(players.get(0).GetScore());
        statistics.SetSecondPlayerScore(players.get(1).GetScore());
        statistics.SetFirstPlayerHit(players.get(0).GetHit());
        statistics.SetSecondPlayerHit(players.get(1).GetHit());
        statistics.SetFirstPlayerMiss(players.get(0).GetMiss());
        statistics.SetSecondPlayerMiss(players.get(1).GetMiss());
        statistics.SetFirstPlayerAverageTimeToAttack(calcAverageTime(0));
        statistics.SetSecondPlayerAverageTimeToAttack(calcAverageTime(1));
        statistics.SetFirstPlayerNumOfTurns(players.get(0).GetNumOfTurnsPlayed());
        statistics.SetSecondPlayerNumOfTurns(players.get(1).GetNumOfTurnsPlayed());
        return statistics;
    }

    private float calcAverageTime(int i_PlayerIndex) {
        if (players.get(i_PlayerIndex).GetNumOfTurnsPlayed() == 0)
            return 0;
        return ((float) (players.get(i_PlayerIndex).GetTotalTimeToAttack()) / (float) (players.get(i_PlayerIndex).GetNumOfTurnsPlayed())) / TO_SECONDS;
    }

    public void InstallMine(int i_Row, int i_Column) throws MineInstallationException, Exception {
        if (isGameRunning) {
            long timeDiff = calcTimeToMakeMove();
            players.get(playerTurn).InstallMine(i_Row, i_Column);
            updateStatistics(timeDiff);
            updateMovesList(i_Row, i_Column, BATTLESHIP_BOARD_TYPE);
            playerTurn = (playerTurn + 1) % 2;
        } else {
            throw new Exception("Game is no longer running.");
        }
    }

    private void updateStatistics(long i_Time) {
        statistics.SetTotalNumberOfTurns(statistics.GetTotalNumberOfTurns() + 1);
        players.get(playerTurn).SetTotalTimeToAttack(players.get(playerTurn).GetTotalTimeToAttack() + i_Time);
        players.get(playerTurn).calcAverageTime();
    }

    public void SurrenderMove() {
        if(isGameRunning)
            playerTurn = (playerTurn + 1) % 2;
        moveIndex--;
        statistics.SetWinnerName(players.get(playerTurn).GetPlayerName());
        isGameRunning = false;
    }

    public SingleMoveInformation MoveForward() {
        if (moveIndex < moves.size() - 1) {
            moveIndex++;
            initReplayMove();
            return moves.get(moveIndex);
        }
        return null;
    }

    public SingleMoveInformation MoveBackwards() {
        if (moveIndex > 0) {
            moveIndex--;
            initReplayMove();
            return moves.get(moveIndex);
        }
        return null;
    }

    private void initReplayMove() {
        for (BattleShipGame.ShipTypes.ShipType type : moves.get(moveIndex).GetShipTypeList()) {
            SimpleIntegerProperty value = shipTypeIdToAmountMap.get(type.getId());
            value.set(type.getAmount());
        }
    }

    public BattleShipBoard.BattleShipSquare GetBattleShipBoardMoveFromReplay(int i_Row, int i_Column) {
        return moves.get(moveIndex).GetBattleshipBoard()[i_Row][i_Column];
    }

    public TrackingBoard.TrackingSquare GetTrackingBoardMoveFromReplay(int i_Row, int i_Column) {
        return moves.get(moveIndex).GetTrackingBoard()[i_Row][i_Column];
    }
}